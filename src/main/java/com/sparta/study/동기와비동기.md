![image](https://user-images.githubusercontent.com/108817236/209669242-e7805786-ef9d-4694-ba9c-0d3246898f05.png)

## 동기식(Synchronous) 통신
* Synchronous란 뜻대로 동시에 일어난다는 뜻이다.
* 요청과 응답의 순서가 보장이 된다.
* 동시에 일어난 다는 것은 Request를 보내게 된다면 얼마나 시간이 걸리든 그 자리에서 Response를 받는다는 말이다.
* 즉, 두 서버 사이의 Transaction 을 맞추겠다는 의미이다.
* 때문에 동기식 통신에서는 요청을 보낸 쓰레드는 응답을 기다리기 때문에 도착하기 전까지는 아무것도 하지 못하는 Block 상태가 된다.

## 동기식 통신의 장단점
* 장점
  * 쓰레드는 요청을 보내고 응답을 받은 후 Task를 처리하므로 요청과 응답의 순서를 보장 받는다.
  * 요청에대한 처리 결과값을 보장받을 수 있다.
* 단점
  * 요청을 보내고 응답이 지연된다면 Block 상태가 지속된다.
  * 이는 뒤에 들어오는 요청을 바로 처리 할 수 없으므로 연결을 바로 맺지 못해 성능 저하를 유발 시킨다.

## 비동기식(Asynchronous) 통신
* ASynchronous란 뜻대로 동시에 수행하지 않는다는 뜻이다.
* 요청과 응답의 순서가 보장되지 않는다.
* 동기식과 다르게 요청을 보낸다고해도 언제 응답이 와도 상관이 없다. 즉 request를 보내고 reposne를 기다리지 않는다.
* 따라서 쓰레드는 다른 Task를 할 수 있으며 이 상태를 NonBlock 상태라고 한다.
* 비동기식은 비동기식 처리를 요청할 때 할일 이 끝난 후 처리결과를 알려주는 콜백이라는 함수를 함께 알려준다.
* 이러한 함수 호출의 흐름은 사용자가 아닌 일을 마친 시스템이 호출하는 형태이기 때문에 콜백이라고 불린다.

## 비동기식 통신의 장단점
* 장점
  * 요청을 보내고 응답을 기다리지않기 때문에 동기식 방식보다 성능이 뛰어나다.
  * 요청을 보내고 그 응답이 오래걸리더라도 다른 Task를 수행 할 수 있기 때문에 자원을 효율적으로 사용 할 수 있다.
* 단점
  * 요청을 보내고 응답을 기다리지 않기 때문에 나중에 보낸 요청에 대한 응답이 먼저 도달 할 수 있다. 즉 순서를 보장하지 않는다.
  * 응답에 대한 처리 결과를 보장받고 처리해야 되는 서비스에는 적합하지 않다.

## 블로킹
![image](https://user-images.githubusercontent.com/108817236/210121070-0943c105-46de-4ee5-b0ff-05eeb9c3ac01.png)
* 블로킹은 A함수가 B함수를 호출하면 제어권은 B함수에게 넘겨준다.
  * 제어권 : 코드를 실행 할 권리

## 논블로킹
![image](https://user-images.githubusercontent.com/108817236/210121102-af8efa57-a1dc-4635-863b-b35ac60165b3.png)
* A함수가 B함수를 실행하더라도 제어권은 그대로 A함수가 가지고 있는다.
* 때문에 B함수를 호출한 이후에도 A함수의 코드를 계속 실행한다.

## 개념 
* 동기와 블로킹 비동기와 논블로킹을 같은 개념으로 착각하기가 쉽다. 하지만 양측의 관심사가 다르다는 것을 알고 넘어가자. 
* A함수는 B함수의 '리턴값'을 필요로한다.(동기) / 제어권을 함수B에게 주고 B가 완료하여 리턴값과 제어권을 돌려줄 때 까지기다린다(블로킹)
* 즉 제어권을 어디에 두고 있느냐 / 리턴값을 신경쓰느냐에 따라 나뉘게 되고 둘이 바라보는 관점이 다르기에 
* 동기/블로킹, 동기/논블로킹, 비동기/블로킹, 비동기/논블로킹 등 의 다양한 좋바이 가능하다.



---
https://velog.io/@kw2577/CSNetwork-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0

https://sudo-minz.tistory.com/21
