# JVM이란 ?
* JVM(Java Virtual Machine)은 '자바 가상머신'의 약자를 지칭하는 말이다.
* JVM은 OS와 Java 애플리케이션 사이에서 중개자 역할을 한다.
* JVM은 바이트코드를 실행 할 수 있는 환경을 제공 해주며 이로인해 코드가 플랫폼에 독립적으로 어느곳에서나 실행이 가능하도록 만들어준다.
* 다시 말하면 OS에 상관없이 Java 애플리케이션을 실행 하도록 해준다. 

# JVM의 구조
![image](https://user-images.githubusercontent.com/108817236/208229308-34ab1844-2925-4031-b3fe-b95b161bda72.png)

### Class Loader(클래스 로더)
* JVM내로 class파일을 로드하고, 배치 작업을 수행하는 모듈이다.
* Runtime 시점에 클래스를 로딩하도록 해주며, 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 된다. 

### Execution Engine(실행 엔진)
* 로드된 클래스의 바이트코드를 실행하는 모듈이 실행엔진이다.
* 클래스로더를 통해 JVM 내의 Runtime Data Areas에 배치된 바이트 코드들은 실행엔진에 의하여 실행된다.
* 실행엔진은 자바 바이트코드를 명령어 단위로 읽어 실행하게 되며 이 과정에서 Interpreter방식과 JIT compiler 방식을 사용한다.

### Interpreter(인터프리터)
* 프로그래밍 언어의 소스 코드를 바로 읽어서 실행하는 프로그램을 말한다.
* 원시코드를 기계어로 번역하여 실행 시키는 컴파일러와 대비된다.
* 한줄씩 읽어서 수행하기 때문에 수행속도가 느리다는 단점이 있다.
* 한줄씩 읽어서 수행하기에 문제가 생긴다면 이후로 넘어가지 않는다. 이는 컴파일러보다 보안상의 이점을 가질 여지가 있다.
* 인터프리터는 플랫폼(하드웨어)에 종속되지 않는다. 따라서 어떤 환경에서라도 인터프리터 언어로 작성된 프로그램을 실행 할 수 있다.

### JIT Compiler (Just In Time Compiler)
* 인터프리터 방식의 단점을 보완하기 위하여 JIT Compiler가 도입이 되었다.
* 컴파일러는 바이트코드를 컴파일하여 Native code로 변환하여 사용한다. 즉 한번 컴파일 된 코드는 빠르게 재사용이 가능하다.
* 다만 컴파일의 동작에도 자원이 들기 때문에  한번만 사용할 코드라면 컴파일 대신 인터프리팅하는게 유리하다.
* 따라서 처음에는 인터프리팅을 사용하다가 일정 수준이 넘어가게 된다면 컴파일러를 사용하는 혼합방식이 적합하다.

### Garbage Collector(가비지 컬렉터)
* 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했음 하지만, 자바에서는 JVM이 프로그램 메모리를 관리한다.
* JVM은 가비지 컬렉션이라는 프로세스를 통해 메모리를 관리한다. 
* 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 한다.
* 실행순서 : 참조되지 않은 객체들을 탐색 후 삭제 → 삭제된 객체의 메모리 반환 → 힙 메모리 재사용

## Runtime Data Area
![image](https://user-images.githubusercontent.com/108817236/208230183-6e37ace6-5489-49d4-a0e3-b4c47c0e8060.png)

### PC Register
* PC Register는 각 쓰레드 별로 하나씩 존재하며 현재 수행 중인 JVM Instruction의 주소를 가지게 된다.
* 즉 스레드가 어떤 명령을 실행 할지 기록하는 부분이다.

### JVM Stack
* 메소드가 호출 될 때 메소드와 메소드의 정보는 JVM Stack에 쌓이게 된다. 즉 매개변수, 지역변수, return주소, 임시변수 등을 기록하는 스택이다.
* 각 스레드별로 생성되기 때문에 다른 스레드는 접근 할 수 없으며 호출이 종료되면 스택에서 정보들이 제거된다.

### Native Method Stack
* 자바 외의 언어로 작성된 네이티브 코드들을 위한 스택이다. Java Native Interface를 통해 호출되는 C/C++ 등의 코드를 수행한다. 

### Method Area
* 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static변수 등의 바이트코드를 보관한다.
* Runtime Constant Pool이라는 별도의 관리 영역도 존재한다. -> 이는 상수자료형을 저장하고 참조하여 중복을 막는 역할을 수행한다.

### Heap
![image](https://user-images.githubusercontent.com/108817236/208230737-6af257ce-34ec-4621-beca-880d184ce8ce.png)
* Runtime 시점에 동적으로 할당하여 사용하는 공간이다.
* 클래스를 이용해 인스턴스를 생성하면 힙영역에 저장된다. 즉 new 연산자를 사용하여 생성된 객체를 저장하는 공간이다.
* Heap은 크게 New/Young 영역, Old 영역, Permanent Generation 3 영역으로 나뉜다. java8 이후에는 Permanent 영역이 Metaspace 영역으로 바뀌었다.

---
https://code-lab1.tistory.com

https://8iggy.tistory.com/229





